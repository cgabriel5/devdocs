// IIFE start
(function(window) {
	"use strict";
	var library = (function() {
		// =============================== Helper Functions
		/**
		 * @description [Generates a simple ID containing letters and numbers.]
		 * @param  {Number} length [The length the ID should be. Max length is 22 characters]
		 * @return {String}        [The newly generated ID.]
		 * @source {http://stackoverflow.com/a/38622545}
		 */
		function id(length) {
			return Math.random()
				.toString(36)
				.substr(2, length);
		}
		/**
		 * @description [Returns index of given value in provided array.]
		 * @param  {Array}    array [The array to check against.]
		 * @param  {Integer}  value [The value to check.]
		 * @return {Integer}        [Returns the index value. -1 if not in array.]
		 */
		function index(array, value) {
			return array.indexOf(value);
		}
		/**
		 * @description [Checks if the given value is in provided array or string.]
		 * @param  {Array|String}   iterable [The array or string to check against.]
		 * @param  {Any}            value    [The value to check.]
		 * @return {Boolean}                 [description]
		 * @source [https://www.joezimjs.com/javascript/great-mystery-of-the-tilde/]
		 * @source [http://stackoverflow.com/questions/12299665/what-does-a-tilde-do-
		 * when-it-precedes-an-expression/12299717#12299717]
		 */
		function includes(iterable, value) {
			return -~index(iterable, value);
		}
		/**
		 * @description [Checks if the provided index exists.]
		 * @param  {Number} index [The index (number) to check.]
		 * @return {Boolean}       [False if -1. Otherwise, true.]
		 */
		function indexed(index) {
			return -~index ? true : false;
		}
		/**
		 * @description [Makes an Array from an array like object (ALO). ALO must have a length property
		 *               for it to work.]
		 * @param  {ALO} alo [The ALO.]
		 * @return {Array}   [The created array.]
		 */
		function to_array(alo) {
			// vars
			var true_array = [];
			// loop through ALO and pushing items into true_array
			for (var i = 0, l = alo.length; i < l; i++) true_array.push(alo[i]);
			return true_array;
		}
		/**
		 * @description [Returns the data type of the provided object.]
		 * @param  {Any} object [The object to check.]
		 * @return {String}    [The data type of the checked object.]
		 */
		var dtype = function(object) {
			// will always return something like "[object {type}]"
			return Object.prototype.toString
				.call(object)
				.replace(/(\[object |\])/g, "")
				.toLowerCase();
		};
		/**
		 * @description [Check if the provided object is of the provided data types.]
		 * @param  {Any} object [The object to check.]
		 * @param  {String}  types  [The allowed data type the object may be.]
		 * @return {Boolean}        [Boolean indicating whether the object is of the
		 *                           allowed data types.]
		 */
		dtype.is = function(object, types) {
			// get the object type
			var type = this(object);
			// prepare the types
			types = "|" + types.toLowerCase().trim() + "|";
			// check if the object's type is in the list
			return Boolean(-~types.indexOf("|" + type + "|"));
		};
		/**
		 * @description [Check if the provided object is not of the provided data types.]
		 * @param  {Any} object [The object to check.]
		 * @param  {String}  types  [The prohibited data types.]
		 * @return {Boolean}        [Boolean indicating whether the object is not of the
		 *                           allowed data types.]
		 */
		dtype.isnot = function(object, types) {
			// return the inverse of the is method
			return !this.is(object, types);
		};
		/**
		 * @description [A class wrapper. Creates a class based on provided object containing class constructor__ and methods__.
		 *               If class needs to extend another, provide it under the extend__ property.]
		 * @param  {Object} cobject [The class object containing three properties: constructor__, methods__, and extend__.
		 *                           .constructor__ {Function}       [The class constructor]
		 *                           .methods__     {Object}         [Object containing class methods.]
		 *                           .extend__      {Boolean|Object} [Set to false if does not need to extend. Otherwise, provide the
		 *                                                            class to extend.]
		 *                           ]
		 * @return {Function}         [Returns class constructor.]
		 */
		function class__(cobject) {
			// cache class data
			var constructor = cobject.constructor__,
				methods = cobject.methods__,
				parent = cobject.extend__;
			// extend if parent class provided
			if (parent) {
				constructor.prototype = Object.create(parent.prototype);
				constructor.prototype.constructor = constructor;
			}
			// cache prototype
			var prototype = constructor.prototype;
			// add class methods to prototype
			for (var method in methods) {
				if (methods.hasOwnProperty(method)) {
					prototype[method] = methods[method];
				}
			}
			return constructor;
		}
		// =============================== Core Library Functions
		/**
		 * @description [Normalizes the XHR options. In essence, function used the provided
		 *               options and resorts to using the default options for user omitted
		 *               options.]
		 * @param  {Object} _ [The http object.]
		 * @return {Object}   [The normalized options.]
		 */
		function normalize_options(_) {
			// get the XHR object
			var options = _.options,
				properties = _.properties;
			// lock the XHR object...properties can no longer be added
			properties.locked = true;
			// new object to contain options
			var normalized = {
				// set the defaults
				url: options.url || document.URL, // default: current URL location
				method: (options.method || "GET").toUpperCase(), // default: GET
				data: options.data || null, // default: null
				// are files being uploaded? If true the content type is left out and left up to browser.
				fileUpload: options.fileUpload || false,
				async: !options.async ? true : options.async, // default: true
				processData: options.processData === false ? false : true,
				postJSON: options.postJSON || false,
				parseJSON: options.parseJSON || false,
				id: options.id || properties.id,
				withCredentials: options.withCredentials || false,
				// {https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType}
				responseType: options.responseType || "",
				timeout: options.timeout || 10000
			};
			// add the id to the objects properties
			properties.id = normalized.id;
			// set the cache flag
			normalized.cache = !options.cache ? false : options.cache; // default: false
			// work the event handlers
			var events = options.events || {},
				noop = function() {
					/* noop */
				};
			// normalize the events object
			events = {
				abort: events.abort || noop,
				progress: events.progress || noop,
				timeout: events.timeout || noop,
				readystatechange: events.readystatechange || noop,
				loadstart: events.loadstart || noop,
				loadend: events.loadend || noop,
				load: events.load || noop,
				error: events.error || noop
			};
			// work the headers
			var headers = options.headers || [],
				default_content_type =
					"application/x-www-form-urlencoded;charset=UTF-8";
			// normalize the content-type
			// Rules...
			// 1) If it's a file upload leave content-type empty unless user provides it via the headers
			// 2) Default to application/x-www-form-urlencoded;charset=UTF-8 for non file uploads
			//
			// if files are being uploaded let the browser set
			// the content type and form boundary set the headers
			// so remove the header if set
			if (!normalized.fileUpload) {
				// add the default content type if nothing was provided
				// check if content type is provided, if not its added
				for (var i = 0, l = headers.length; i < l; i++) {
					// check if the content type has been added
					if (headers[i][0].toLowerCase() === "content-type") break;
					// else if we get to the last one we add the content-type
					if (i === l - 1) {
						// add if not a file upload
						headers.push(["Content-Type", default_content_type]);
					}
				}
				// if no headers add the basic content-type header
				if (!headers.length) {
					headers.push(["Content-Type", default_content_type]);
				}
			}
			// add the events, headers to the normalized object
			normalized.events = events;
			normalized.headers = headers;
			// set the options
			_.options = normalized;
			// return the options
			return normalized;
		}
		/**
		 * @description [Removed all events from XHR object.]
		 * @param  {Object} _ [The http object.]
		 * @return {Undefined}   [Nothing is returned.]
		 */
		function remove_events(_) {
			// get the XHR object
			var xhr = _.xhr,
				callbacks = _.properties.callbacks;
			// loop over callbacks and remove them
			for (var callback in callbacks) {
				if (callbacks.hasOwnProperty(callback)) {
					xhr.removeEventListener(
						callback,
						callbacks[callback],
						false
					);
				}
			}
		}
		// =============================== Library Class
		var Library = class__({
			/**
			 * @description [The library class constructor.]
			 * @param  {String} url [The request url.]
			 * @return {Undefined}     [Nothing is returned.]
			 */
			constructor__: function(url) {
				// https://toddmotto.com/writing-a-standalone-ajax-xhr-javascript-micro-library/
				// http://blog.garstasio.com/you-dont-need-jquery/ajax/#getting
				// http://www.w3schools.com/jquery/ajax_ajax.asp
				// http://stackoverflow.com/questions/14322984/differences-between-contenttype-and-datatype-in-jquery-ajax-function
				// if user does not invoke library with new keyword we use it for them by
				// returning a new instance of the library with the new keyword.
				if (!(this instanceof Library)) return new Library();
				// create the new XHR object
				this.xhr = new XMLHttpRequest();
				// set responseJSON property
				this.xhr.responseJSON = null;
				// make a users options object
				this.options = {};
				// set the url if provided
				if (url) this.options.url = url;
				// XHR library properties
				this.properties = {
					id: id(22),
					callbacks: {},
					aborted: false,
					locked: false,
					opened: false,
					resolved: undefined,
					rejected: undefined,
					path: "created"
				};
			},
			// class methods
			methods__: {
				/**
				 * @description [Adds URL to options object.]
				 * @param  {String} url [The URL.]
				 * @return {Undefined}     [Nothing is returned.]
				 */
				url: function(url) {
					// cache the object
					var _ = this;
					// option cannot be set if object has been opened
					if (_.properties.locked) return _;
					// set the option
					_.options.url = url;
					// return self to chain methods
					return _;
				},
				/**
				 * @description [Adds method to options object.]
				 * @param  {String} method [The request method.]
				 * @return {Undefined}     [Nothing is returned.]
				 */
				method: function(method) {
					// cache the object
					var _ = this;
					// option cannot be set if object has been opened
					if (_.properties.locked) return _;
					// set the option
					_.options.method = method;
					// return self to chain methods
					return _;
				},
				/**
				 * @description [Adds data to options object.]
				 * @param  {Any} data [The data to send request with.]
				 * @return {Undefined}     [Nothing is returned.]
				 */
				data: function(data) {
					// cache the object
					var _ = this;
					// option cannot be set if object has been opened
					if (_.properties.locked) return _;
					// set the option
					_.options.data = data;
					// return self to chain methods
					return _;
				},
				/**
				 * @description [Adds fileUpload flag to options object.
				 *               Flag indicates whether files are being uploaded.]
				 * @param  {Boolean} flag [Bool indicating whether to set flag.]
				 * @return {Undefined}     [Nothing is returned.]
				 */
				fileUpload: function(flag) {
					// cache the object
					var _ = this;
					// option cannot be set if object has been opened
					if (_.properties.locked) return _;
					// set the option
					_.options.fileUpload = flag;
					// return self to chain methods
					return _;
				},
				/**
				 * @description [Adds postJSON flag to options object.
				 *               Flag indicates whether data should be stringified.]
				 * @param  {Boolean} flag [Bool indicating whether to set flag.]
				 * @return {Undefined}     [Nothing is returned.]
				 */
				postJSON: function(flag) {
					// cache the object
					var _ = this;
					// option cannot be set if object has been opened
					if (_.properties.locked) return _;
					// set the option
					_.options.postJSON = flag;
					// return self to chain methods
					return _;
				},
				/**
				 * @description [Adds parseJSON flag to options object.
				 *               Flag indicates whether req response should be JSON parsed.]
				 * @param  {Boolean} flag [Bool indicating whether to set flag.]
				 * @return {Undefined}     [Nothing is returned.]
				 */
				parseJSON: function(flag) {
					// cache the object
					var _ = this;
					// option cannot be set if object has been opened
					if (_.properties.locked) return _;
					// set the option
					_.options.parseJSON = flag;
					// return self to chain methods
					return _;
				},
				/**
				 * @description [Adds cache flag to options object.
				 *               Flag indicates whether request needs to be cached.]
				 * @param  {Boolean} flag [Bool indicating whether to set flag.]
				 * @return {Undefined}     [Nothing is returned.]
				 */
				cache: function(flag) {
					// cache the object
					var _ = this;
					// option cannot be set if object has been opened
					if (_.properties.locked) return _;
					// set the option
					_.options.cache = flag;
					// return self to chain methods
					return _;
				},
				/**
				 * @description [Adds async flag to options object.
				 *               Flag indicates whether request is async.]
				 * @param  {Boolean} flag [Bool indicating whether to set flag.]
				 * @return {Undefined}     [Nothing is returned.]
				 */
				async: function(flag) {
					// cache the object
					var _ = this;
					// option cannot be set if object has been opened
					if (_.properties.locked) return _;
					// set the option
					_.options.async = flag;
					// return self to chain methods
					return _;
				},
				/**
				 * @description [Adds headers object to options object.]
				 * @param  {Object} key  [The header name.]
				 * @param  {Object} name [The header value.]
				 * @return {Undefined}     [Nothing is returned.]
				 */
				header: function(key, value) {
					// cache the object
					var _ = this;
					// option cannot be set if object has been opened
					if (_.properties.locked) return _;
					// add the option
					if (!_.options.headers) _.options.headers = [];
					// append provided header to the headers array
					_.options.headers.push([key, value]);
					// return self to chain methods
					return _;
				},
				/**
				 * @description [Adds processData flag to options object.
				 *               Flag indicates whether data needs to be processed.]
				 * @param  {Boolean} flag [Bool indicating whether to set flag.]
				 * @return {Undefined}     [Nothing is returned.]
				 */
				processData: function(flag) {
					// cache the object
					var _ = this;
					// option cannot be set if object has been opened
					if (_.properties.locked) return _;
					// set the option
					_.options.processData = flag;
					// return self to chain methods
					return _;
				},
				/**
				 * @description [Adds id to options object.]
				 * @param  {String} id [The id. Needs to be unique.]
				 * @return {Undefined}     [Nothing is returned.]
				 */
				id: function(id) {
					// cache the object
					var _ = this;
					// option cannot be set if object has been opened
					if (_.properties.locked) return _;
					// set the option
					_.options.id = id;
					// return self to chain methods
					return _;
				},
				/**
				 * @description [Adds withCredentials flag to options object.
				 *               Flag indicates whether prop needs to be set for request.]
				 * @param  {Boolean} flag [Bool indicating whether to set flag.]
				 * @return {Undefined}     [Nothing is returned.]
				 */
				withCredentials: function(flag) {
					// cache the object
					var _ = this;
					// option cannot be set if object has been opened
					if (_.properties.locked) return _;
					// set the option
					_.options.withCredentials = flag;
					// return self to chain methods
					return _;
				},
				/**
				 * @description [Adds the request response type.]
				 * @param  {Number} type [The response type..]
				 * @return {Undefined}     [Nothing is returned.]
				 */
				responseType: function(type) {
					// cache the object
					var _ = this;
					// option cannot be set if object has been opened
					if (_.properties.locked) return _;
					// set the option
					_.options.responseType = type;
					// return self to chain methods
					return _;
				},
				/**
				 * @description [Adds timeout time to options object.]
				 * @param  {Number} time [The time to timeout request after.]
				 * @return {Undefined}     [Nothing is returned.]
				 */
				timeout: function(time) {
					// cache the object
					var _ = this;
					// option cannot be set if object has been opened
					if (_.properties.locked) return _;
					// set the option
					_.options.timeout = time;
					// return self to chain methods
					return _;
				},
				/**
				 * @description [Adds events object to options object.]
				 * @param  {Object} events [The events object.]
				 * @return {Undefined}     [Nothing is returned.]
				 */
				events: function(events) {
					// cache the object
					var _ = this;
					// option cannot be set if object has been opened
					if (_.properties.locked) return _;
					// set the option
					_.options.events = events;
					// return self to chain methods
					return _;
				},
				/**
				 * @description [Works the XHR request by normalizing options,
				 *               applies event listeners, sets headers, processes
				 *               data, and sends the request.]
				 * @return {Promise}     [XHR request is wrapped in a promise.]
				 */
				run: function() {
					// cache the object
					var _ = this;
					// get the XHR object
					var xhr = _.xhr,
						// normalize the options
						options = normalize_options(_),
						properties = _.properties,
						callbacks = properties.callbacks;
					// option cannot be set if object has been opened
					if (properties.opened) return _;
					// get the options
					var url = options.url, // default: current URL location
						method = options.method, // default: GET
						data = options.data, // default: null
						// are files being uploaded? If true the content type is left out and left up to browser.
						// files = options.fileUpload,
						cache = options.cache, // default: true for GET requests
						async = options.async, // default: true
						// default: application/x-www-form-urlencoded;charset=UTF-8, empty for file uploads
						// content_type = options.contentType,
						// default: true for strings and objects containing key:value pairs
						process_data = options.processData,
						// {http://stackoverflow.com/questions/17785592/difference-between-json-stringify-and-json-parse}
						post_json = options.postJSON,
						parse_json = options.parseJSON,
						// {http://stackoverflow.com/a/38622545}
						id = options.id, // default: <random_alphanum_string> (used to abort request)
						credentials = options.credentials, // default: false
						response_type = options.responseType, // default: ""
						timeout = options.timeout, // default: 10 seconds
						headers = options.headers,
						events = options.events, // event handlers
						abort = events.abort,
						progress = events.progress,
						timeoutfn = events.timeout,
						readystatechange = events.readystatechange,
						loadstart = events.loadstart,
						loadend = events.loadend;
					// not used as a promise resolved/rejected functions are used
					// load = events.load,
					// error = events.error;
					// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState
					// 0   UNSENT  Client has been created. open() not called yet.
					// 1   OPENED  open() has been called.
					// 2   HEADERS_RECEIVED    send() has been called, and headers and status are available.
					// 3   LOADING Downloading; responseText holds partial data.
					// 4   DONE    The operation is complete.
					// xhr.readyState === 0 here
					// set the xhr path to unsent (init xhr)
					properties.path += ";unsent"; // http://stackoverflow.com/questions/21485545/is-there-a-way-to-tell-if-an-es6-promise-is-fulfilled-rejected-resolved
					// -------------------------
					// add xhr to pool
					xhrs[id] = _;
					// -------------------------
					// wrap XHR in a Promise
					return new Promise(function(resolve, reject) {
						// store callbacks in objects properties
						// this is done within the promise as the
						// resolve/reject functions are needed for
						// the load/error events
						callbacks.loadstart = loadstart;
						callbacks.loadend = loadend;
						callbacks.load = function(e) {
							// once finished resolve promise
							// set properties
							properties.path += ";done;resolved";
							properties.resolved = true;
							properties.rejected = false;
							// remove xhr callbacks
							remove_events(_);
							// check if user wants their response JSON parsed
							if (parse_json) {
								try {
									// {http://stackoverflow.com/questions/4467044/proper-way-to-catch-exception-from-javascript-method-json-parse}
									// parse the JSON and set result to XHR
									xhr.responseJSON = JSON.parse(
										xhr.responseText
									);
								} catch (error) {
									console.warn(error);
								}
							}
							resolve(xhr);
						};
						callbacks.error = function(e) {
							// reject on network errors
							// set properties
							properties.path += ";done;rejected";
							properties.resolved = false;
							properties.rejected = true;
							// remove xhr callbacks
							remove_events(_);
							// check internet connection here {https://davidwalsh.name/detecting-online}
							// http://www.html5rocks.com/en/tutorials/es6/promises/#toc-error-handling
							reject(xhr);
						};
						callbacks.progress = function(e) {
							if (e.lengthComputable) {
								var percent = e.loaded / e.total * 100;
								progress.call(xhr, e, percent);
							} else {
								// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
								// Unable to compute progress information since the total size is unknown
							}
						};
						callbacks.abort = function(e) {
							properties.path += ";aborted-callback";
							// remove xhr callbacks
							remove_events(_);
							// run the callback
							abort.call(xhr, e);
						};
						callbacks.timeout = function(e) {
							// reject on timeout
							properties.path += ";timedout";
							// reject the promise
							// check internet connection here {https://davidwalsh.name/detecting-online}
							// reject(xhr); // http://www.html5rocks.com/en/tutorials/es6/promises/#toc-error-handling
							// remove xhr callbacks
							remove_events(_);
							// run timeout callback if provided
							if (timeoutfn) timeoutfn.call(xhr, e);
							reject(new TypeError("Request timedout."));
						};
						callbacks.readystatechange = function(e) {
							var states = {
								"1": ";opened",
								"2": ";headers-received",
								"3": ";loading",
								"4": ";finished"
							};
							// append to the path according to the XHR ready state
							properties.path += states[xhr.readyState];
							// call handler if provided
							if (readystatechange) readystatechange.call(xhr, e);
						};
						// set the request timeout
						xhr.timeout = timeout;
						// add timestamp to prevent caching
						// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache
						if (!cache)
							url +=
								(url.indexOf("?") !== -1 ? "&_=" : "?_=") +
								new Date().getTime();
						// initialize request
						// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open
						xhr.open(method, url, async);
						// set request as opened
						properties.opened = true;
						// http://stackoverflow.com/questions/18701282/what-is-content-type-and-datatype-in-an-ajax-request
						// http://stackoverflow.com/questions/19694503/ajax-setrequestheader-content-type-application-x-www-form-urlencoded-and-ch
						// http://stackoverflow.com/questions/16819502/application-x-www-form-urlencoded-and-charset-utf-8
						// http://stackoverflow.com/questions/2053242/how-to-post-a-html-form-using-javascript-that-has-both-application-x-www-form-u
						// http://stackoverflow.com/questions/12348216/uploading-a-file-with-xmlhttprequest-missing-boundary-in-multipart-form-data
						// http://stackoverflow.com/questions/2436716/is-application-x-www-form-urlencoded-default-for-html-form
						// https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4
						// https://developer.mozilla.org/en-US/docs/Web/API/FormData/Using_FormData_Objects -> FormData tutorial
						// for files use: multipart/form-data;charset=UTF-8, anything else: application/x-www-form-urlencoded;charset=UTF-8
						// headers list {https://en.wikipedia.org/wiki/List_of_HTTP_header_fields}
						for (var i = 0, l = headers.length; i < l; i++) {
							xhr.setRequestHeader(headers[i][0], headers[i][1]);
						}
						// if CORS is needed...
						// https://www.html5rocks.com/en/tutorials/cors/
						// https://developers.google.com/web/updates/2015/03/introduction-to-fetch#sending_credentials_with_a_fetch_request
						// https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Requests_with_credentials
						// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials
						// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
						xhr.withCredentials = credentials;
						// {https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType}
						// set the response type
						xhr.responseType = response_type;
						// fetch resources
						// https://davidwalsh.name/fetch
						// https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
						// https://developer.mozilla.org/en-US/docs/Web/API/Response
						// https://developer.mozilla.org/en-US/docs/Web/API/Request
						// https://developer.mozilla.org/en-US/docs/Web/API/Request/mode
						// https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials
						// process data if data is either a string or [object Object] and process_data is not set to false
						var data_type = dtype(data);
						if (
							process_data !== false &&
							(data_type === "string" || data_type === "object")
						) {
							// if data is a string we turn into an object
							if (typeof data === "string") {
								// breakdown and turn data into an object
								var parameters = data.split("&"),
									parsed_data = {};
								for (
									var i = 0, l = parameters.length;
									i < l;
									i++
								) {
									var parameter = parameters[i].split("=");
									parsed_data[parameter[0]] = parameter[1];
								}
								// reset data var
								data = parsed_data;
							}
							// else if already object just continue
							// now we escape special characters in parameters
							// http://stackoverflow.com/questions/75980/when-are-you-supposed-to-use-escape-instead-of-encodeuri-encodeuricomponent
							// http://stackoverflow.com/questions/4540753/should-i-use-encodeuri-or-encodeuricomponent-for-encoding-urls
							// http://stackoverflow.com/questions/15847882/how-to-send-raw-text-with-xmlhttp-request/39109184#39109184
							// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent
							var data_string = "",
								i = 0;
							for (var key in data) {
								if (data.hasOwnProperty(key)) {
									data_string +=
										(i !== 0 ? "&" : "") +
										encodeURIComponent(key) +
										"=" +
										encodeURIComponent(data[key]);
									i++;
								}
							}
							// reset data var
							data = data_string;
						}
						// else...data is of the following types and those do not get processed.
						// (new Int8Array(), new Blob(), new FormData(), document, null)
						// stringify object if post_json flag is set
						if (post_json) {
							try {
								data = JSON.stringify(data);
							} catch (error) {
								console.warn(error);
							}
						}
						// -------------------------
						// listen to when request starts and ends
						// http://stackoverflow.com/questions/6233927/microsecond-timing-in-javascript
						xhr.addEventListener(
							"loadstart",
							callbacks.loadstart,
							false
						);
						xhr.addEventListener(
							"loadend",
							callbacks.loadend,
							false
						);
						// listen to request state
						xhr.addEventListener(
							"progress",
							callbacks.progress,
							false
						);
						xhr.addEventListener("abort", callbacks.abort, false);
						// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/timeout
						xhr.addEventListener(
							"timeout",
							callbacks.timeout,
							false
						);
						// http://stackoverflow.com/questions/14946291/can-one-replace-xhr-onreadystatechange-with-xhr-onload-for-ajax-calls
						// http://stackoverflow.com/questions/9181090/is-onload-equal-to-readystate-4-in-xmlhttprequest
						// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/onreadystatechange
						// readystatechange wont fire when canceled with abort() method
						xhr.addEventListener(
							"readystatechange",
							callbacks.readystatechange,
							false
						);
						// listen for request completion
						// http://stackoverflow.com/questions/6783053/xmlhttprequest-is-always-calling-load-event-listener-even-when-response-has-e/21025981#21025981
						xhr.addEventListener("load", callbacks.load, false);
						// **Note: user must handle HTTP request error response on their own.
						// this is really only invoked for network-level errors.
						xhr.addEventListener("error", callbacks.error, false);
						// -------------------------
						// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send
						// possible data types: null, new Int8Array(), new Blob(), document, 'string', & new FormData()
						xhr.send(data);
					});
				},
				/**
				 * @description [Returns the needed http object property.]
				 * @param  {String} property [The wanted property.]
				 * @return {String}     [The wanted property.]
				 */
				getProp: function(property) {
					// cache the object
					var _ = this,
						properties = _.properties;
					// a property must be provided
					// it must also be a string
					if (!property || !dtype(property, "string")) return;
					// property must exist
					if (
						!(property in properties) ||
						!properties.hasOwnProperty(property)
					)
						return;
					// return the property
					return properties[property];
				},
				abort: function() {
					// single xhr abort...
					abort(this);
				}
			},
			// class to extend
			extend__: false
		});
		// return library to add to global scope later...
		return Library;
	})();
	// =============================== Global Library Functions/Methods/Vars
	// keep track of requests
	var xhrs = {};
	// flag indicating whether the reqs have been
	// aborted on the beforunload/unload events
	var unloaded = false;
	/**
	 * @description [Aborts the provided http request object.]
	 * @param  {Object} _ [The http object to abort.]
	 * @return {Object}     [The http object.]
	 */
	function abort(_) {
		// get the XHR object
		var xhr = _.xhr,
			properties = _.properties;
		// check if already aborted, if so return
		if (properties.aborted) return xhr;
		// only abort if req is has not been resolved or rejected
		if (!properties.resolved && !properties.rejected) {
			// abort the request
			xhr.abort();
			// set aborted property to true
			properties.aborted = true;
			// update the path
			properties.path += ";aborted";
			delete xhrs[properties.id]; // remove xhr from pool
		} // else the req was already aborted
		return xhr; // return the xhr
	}
	/**
	 * @description [Global library abort method. Aborts all requests.]
	 * @return {Undefined}     [Nothing is returned.]
	 * @concept {http://stackoverflow.com/questions/32497035/abort-ajax-request-in-a-promise}
	 */
	library.abortAll = function() {
		// loop over xhrs
		for (var id in xhrs) {
			if (xhrs.hasOwnProperty(id)) {
				// abort the xhr
				abort(xhrs[id]);
			}
		}
	};
	/**
	 * @description [Unload event handler. Aborts all requests when the
	 *               page is unloaded (refreshed, tab closed).]
	 * @param  {Object} event [The event object.]
	 * @return {Undefined}     [Nothing is returned.]
	 */
	function unload(e) {
		// http://stackoverflow.com/questions/4945932/window-onbeforeunload-ajax-request-problem-with-chrome
		// http://stackoverflow.com/questions/6895564/difference-between-onbeforeunload-and-onunload
		// prevent double execution of function
		if (unloaded) return;
		// abort all requests
		library.abortAll();
		// check if xhr pool is empty
		if (!Object.keys(xhrs).length) {
			// set flag to true
			unloaded = true;
			// remove the event listeners
			window.removeEventListener("beforeunload", unload, false);
			window.removeEventListener("unload", unload, false);
		}
	}
	// set unload listeners
	window.addEventListener("beforeunload", unload, false);
	window.addEventListener("unload", unload, false);
	// =============================== Attach Library To Global Scope
	// add to global scope for ease of use
	// use global app var or create it if not present
	var app = window.app || (window.app = {});
	// get the libs object from within the app object
	// if it does not exist create it
	var libs = app.libs || (app.libs = {});
	// add the library to the libs object
	libs.http = library;
	// IIFE end
})(window);

;(function () {
	'use strict';

	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */

	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/


	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;


		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;


		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;


		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;


		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;


		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;


		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;


		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;

		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;

		/**
		 * The maximum time for a tap
		 *
		 * @type number
		 */
		this.tapTimeout = options.tapTimeout || 700;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}


		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		if (deviceIsAndroid) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {

			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
	*
	* @type boolean
	*/
	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


	/**
	 * iOS 6.0-7.* requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {

		// Don't send a synthetic click to disabled inputs (issue #62)
		case 'button':
		case 'select':
		case 'textarea':
			if (target.disabled) {
				return true;
			}

			break;
		case 'input':

			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
				return true;
			}

			break;
		case 'label':
		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
		case 'video':
			return true;
		}

		return (/\bneedsclick\b/).test(target.className);
	};


	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
		case 'textarea':
			return true;
		case 'select':
			return !deviceIsAndroid;
		case 'input':
			switch (target.type) {
			case 'button':
			case 'checkbox':
			case 'file':
			case 'image':
			case 'radio':
			case 'submit':
				return false;
			}

			// No point in attempting to focus disabled inputs
			return !target.disabled && !target.readOnly;
		default:
			return (/\bneedsfocus\b/).test(target.className);
		}
	};


	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];

		// Synthesise a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function(targetElement) {

		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};


	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};


	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};


	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};


	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection;

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		if (deviceIsIOS) {

			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {

				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			event.preventDefault();
		}

		return true;
	};


	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};


	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};


	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {

		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};


	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			this.cancelNextClick = true;
			return true;
		}

		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = event.timeStamp;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {

			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {

			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};


	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};


	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {

		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {

				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};


	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};


	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};


	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;
		var firefoxVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (chromeVersion) {

			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		// Firefox version - zero for other browsers
		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (firefoxVersion >= 27) {
			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

			metaViewport = document.querySelector('meta[name=viewport]');
			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
				return true;
			}
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		return false;
	};


	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};


	if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {

		// AMD. Register as an anonymous module.
		define(function() {
			return FastClick;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = FastClick.attach;
		module.exports.FastClick = FastClick;
	} else {
		window.FastClick = FastClick;
	}
}());

document.onreadystatechange = function() {
	// All resources have loaded (document + subresources).
	if (document.readyState === "complete") {
		// Third-party //

		// Init FastClickJS.
		if ("addEventListener" in document) {
			FastClick.attach(document.body);
		}

		// Grab the HTTP library.
		var http = window.app.libs.http;

		// Elements //

		// Get needed elements.
		var $delement = document.documentElement;
		var $loader = document.getElementById("loader");
		var $topbar = document.getElementById("topbar");
		var $sidebar = document.getElementById("sidebar");
		var $markdown = document.getElementById("markdown");
		var $overlay = document.getElementsByClassName("sidebar-overlay")[0];

		// Variables //

		// The request filepath.
		var REQUEST_PATH = "./devdocs/data.json";
		var SCROLL_TIME = 250;

		// Functions //

		/**
		 * Debounces provided function.
		 *
		 * @param {function} func - The function to debounce.
		 * @param {number} time - The time to debounce by.
		 * @param {object} scope - The scope in which to run function with.
		 * @param {boolean} run_immediately - Flag indicating whether the
		 *     function should run immediately.
		 *
		 * @return {function} - The new debounced function.
		 *
		 * @resource debouncing function from John Hann
		 * @resource [http://unscriptable.com/index.php/2009/03/20/debouncing-javascript-methods/]
		 * @resource [https://www.paulirish.com/2009/throttled-smartresize-jquery-event-handler/]
		 * @resource [https://davidwalsh.name/javascript-debounce-function]
		 * @resource [https://github.com/cgabriel5/snippets/blob/master/js/function/debounce.js]
		 */
		var debounce = function(func, time, scope, run_immediately) {
			var timeout;
			return function() {
				var context = scope || this,
					args = arguments;

				function delayed() {
					if (!run_immediately) {
						func.apply(context, args);
					}
					timeout = null;
				}
				if (timeout) {
					clearTimeout(timeout);
				} else if (run_immediately) {
					func.apply(context, args);
				}
				timeout = setTimeout(delayed, time || 100);
			};
		};

		/**
		 * Determine correct requestAnimationFrame function.

		 * @return {function} - The correct function to use.
		 */
		var request_aframe = (function() {
			return (
				window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				function(callback) {
					window.setTimeout(callback, 250 / 60);
				}
			);
		})();

		/**
		 * An custom animated scrolling function.
		 *
		 * @param  {Object} window - The window object.
		 * @return {function} - The scrolling function.
		 *
		 * @resource [https://github.com/madebysource/animated-scrollto]
		 */
		var scroll = (function(window) {
			var ease_in_out_quad = function(t, b, c, d) {
				t /= d / 2;
				if (t < 1) return c / 2 * t * t + b;
				t--;
				return -c / 2 * (t * (t - 2) - 1) + b;
			};

			return function(element, to, duration, callback) {
				var start = element.scrollTop,
					change = to - start,
					animation_start = +new Date();
				var animating = true;
				var lastpos = null;

				var animate_scroll = function() {
					if (!animating) {
						if (callback) {
							callback();
						}
						return;
					}
					request_aframe(animate_scroll);
					var now = +new Date();
					var val = Math.floor(
						ease_in_out_quad(
							now - animation_start,
							start,
							change,
							duration
						)
					);
					if (lastpos) {
						if (lastpos === element.scrollTop) {
							lastpos = val;
							element.scrollTop = val;
						} else {
							animating = false;
						}
					} else {
						lastpos = val;
						element.scrollTop = val;
					}
					if (now > animation_start + duration) {
						element.scrollTop = to;
						animating = false;
					}
				};
				request_aframe(animate_scroll);
			};
		})(window);

		/**
		 * The loader animation function.
		 *
		 * @param  {eventobject} e - The browser event object.
		 * @return {undefined} - Nothing.
		 */
		var done_loader = false;
		var loader = function(e) {
			function animate_loader() {
				if (e.lengthComputable && done_loader !== true) {
					// Calculate the percentage.
					var percent = e.loaded / e.total * 100;

					// Update the loader with the percent.
					$loader.style.width = `${percent}%`;

					// Once fully loaded end animating.
					if (percent === 100) {
						done_loader = true;
						return;
					} else {
						// Else continue animating.
						request_aframe(animate_loader);
					}
				}
			}
			// Start animating.
			request_aframe(animate_loader);
		};

		/**
		 * Parse the URL query parameters.
		 *
		 * @return {object} - Object containing the parameter pairs.
		 */
		var parameters = function() {
			// Get the query.
			var query = location.search.replace(/^\?/, "");

			// Contain parameter key/values here.
			var params = {};

			// Loop over pairs.
			query.split("&").forEach(function(part) {
				var delimiter_index = part.indexOf("=");
				var key = decodeURIComponent(
					part.substring(0, delimiter_index)
				);
				var value = decodeURIComponent(
					part.substring(delimiter_index + 1, part.length)
				);
				params[key] = value;
			});

			return params;
		};

		/**
		 * Detect whether device supports touch events.
		 *
		 * @return {boolean} - Boolean indicating touch support.
		 *
		 * @resource [https://stackoverflow.com/a/20293441]
		 */
		var touchsupport = function() {
			try {
				document.createEvent("TouchEvent");
				return true;
			} catch (e) {
				return false;
			}
		};

		/**
		 * Get the provided element's top coordinate position in relation to the
		 *     page and y-scroll amount.
		 *
		 * @return {number} - The top position.
		 */
		var get_element_top_pos = function($el) {
			return $el.getBoundingClientRect().top + window.pageYOffset - 50;
		};

		// ------------------------------------------------------------

		// Create a new HTTP request.
		var req = new http(REQUEST_PATH);
		// Parse the data as JSON.
		req.parseJSON(true);
		// Listen to the HTTP request progress event.
		req.events({
			progress: loader
		});
		// Run the request.
		req
			.run()
			.then(function(xhr) {
				if (
					xhr.status >= 200 &&
					xhr.status < 300 &&
					xhr.readyState === 4
				) {
					// Return the JSON response.
					return xhr.responseJSON;
				} else {
					return Promise.reject(
						"Failed to load configuration data file."
					);
				}
			})
			.then(function(data) {
				// Fade-out the loader.
				setTimeout(function() {
					$loader.style.opacity = `0`;
					setTimeout(function() {
						$loader.style.display = "none";
					}, 200);
				}, 500);

				// Set the title if provided.
				if (data.title) {
					document.title = data.title;
				}

				// Note: Pre-load logo to prevent "blinking in".
				return new Promise(function(resolve, reject) {
					// Only load image if provided in the data object.
					if (data.logo) {
						// Create new HTMLImageElement instance.
						var image = new Image();

						// Attach event listeners to image instance.
						image.onload = function() {
							resolve(data);
						};
						image.onerror = function() {
							reject();
						};

						// Add the image source file.
						image.src = data.logo;
					} else {
						// If the data object does not contain an image simply
						// resolve the promise to continue with the chain.
						resolve(data);
					}
				}).then(null, function() {
					return Promise.reject("Failed to the load the logo.");
				});
			})
			.then(function(data) {
				console.log(data);

				// Variables:Scoped:Inner //

				// Store the currently displayed file.
				var current_file;
				var menu_show_count = 0;

				// Functions:Scoped:Inner //

				// Contain all the sidebar submenu heights.
				var heights = {};
				/**
				 * Get the height of a submenu using a virtual element.
				 *
				 * @param  {HTMLElement} $new_current - The newly clicked
				 *     menu directory element.
				 * @param  {string} filename - The file name.
				 * @return {string} - The submenu height with 'px' unit.
				 */
				function get_height($new_current, filename) {
					// Don't recalculate if previously calculated.
					if (heights.hasOwnProperty(filename)) {
						return heights[filename];
					}

					// Create a virtual clone of the element.
					var clone = $new_current.nextElementSibling.cloneNode(true);
					// Set the height to its normal height.
					clone.style.height = "auto";

					// Get the height using a virtual dom.
					var html = `<div id="virtual-height-element" class="menu">${
						clone.outerHTML
					}</div>`;

					// Inject the clone to the DOM.
					document
						.getElementsByTagName("body")[0]
						.insertAdjacentHTML("afterbegin", html);

					// Get the virtual element.
					var $vel = document.getElementById(
						"virtual-height-element"
					);

					// Calculate the element height.
					var height = getComputedStyle($vel, null).height;

					// Remove the virtual element.
					$vel.parentNode.removeChild($vel);

					// Finally, store the height for future runs.
					heights[filename] = height;

					return height;
				}

				/**
				 * Inject the data HTML to the page.
				 *
				 * @param  {string} filename - The file name.
				 * @param  {HTMLElement} $new_current - The newly clicked
				 *     menu directory element.
				 * @return {undefined} - Nothing.
				 */
				function inject(filename, $new_current) {
					// Don't inject the same file content when the menu
					// item is clicked again.
					if (filename === current_file) {
						return;
					}

					// Default to the first file when one does not exist.
					if (!current_file) {
						current_file = data.first_file;
					}

					// Get the file content.
					var file = data.files[filename];

					// Show 404 file when selected file does not exist.
					if (!file) {
						var error_404 = "_404";
						file = data.files[error_404];
						filename = error_404;
					}

					// Un-highlight/Highlight:

					// Un-highlight the current highlighted menu element.
					var $current = document.querySelector(
						`[data-file="${current_file}"]`
					);
					if ($current) {
						var $parent = $current.parentNode;
						// Remove the highlight.
						$parent.classList.remove("active-page");
						$parent.nextElementSibling.style.height = 0;
						$parent.nextElementSibling.style.opacity = 0;

						// Un-highlight the menu arrow and reset to right
						// position.
						var menu_arrow = $parent.children[0];
						var menu_classes = menu_arrow.classList;
						menu_classes.remove("menu-arrow-active");
						menu_classes.remove("fa-angle-down");
						menu_classes.add("fa-angle-right");
					}

					// Set the new highlight for the new current element.
					if (!$new_current && filename !== "_404") {
						$new_current = document.querySelector(
							`[data-file="${filename}"]`
						).parentNode;
					}
					if (filename !== "_404") {
						// Get the menu arrow element and its CSS classes.
						var menu_arrow = $new_current.children[0];
						var menu_classes = menu_arrow.classList;

						setTimeout(function() {
							// Change text color to blue.
							$new_current.classList.add("active-page");
							// Change the menu arrow to be active (blue/down).
							menu_classes.add("menu-arrow-active");
							menu_classes.remove("fa-angle-right");
							menu_classes.add("fa-angle-down");

							$new_current.nextElementSibling.style.height = get_height(
								$new_current,
								filename
							);
							$new_current.nextElementSibling.style.opacity = 1;

							// Increment the show counter.
							menu_show_count++;
						}, !menu_show_count ? 500 : 300);
					}

					// Reset the active element.
					current_file = filename;

					// Inject the html.
					$markdown.innerHTML = file;

					// Get the hash.
					var hash = location.hash;

					// Scroll to hash.
					if (hash) {
						var $el = document.getElementById(hash.slice(1));
						if ($el) {
							var $parent = $el.parentNode;

							// Use a timeout to let the injected HTML load
							// and parse properly. Otherwise, getBoundingClientRect
							// will return incorrect values.
							setTimeout(function() {
								scroll(
									$delement,
									get_element_top_pos($parent),
									SCROLL_TIME,
									function() {
										$parent.classList.add("highlight");
									}
								);
							}, 500);
						}
					}
				}

				/**
				 * Determine whether an element has been totally scrolled.
				 *
				 * @return {Boolean} - Boolean indicating whether element has been totally scrolled.
				 *
				 * @resource [https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions]
				 */
				function is_element_max_scrolled($el) {
					return $el.scrollHeight - $el.scrollTop <= $el.clientHeight;
				}

				/**
				 * Function disables mobile rubber band scrolling. When the scrollbar
				 *     is at the very top (scrollTop = 0) or the element has been
				 *     totally scrolled, prevent default browser behavior; i.e. rubber
				 *     band scrolling.
				 *
				 * @return {Undefined} - Nothing.
				 */
				function disable_rubber_band(event, $el, cY) {
					// Get the difference form the touchstart Y and the touchmove Y.
					var clientY = event.targetTouches[0].clientY - cY;

					// Element is at the top of its scroll.
					if ($el.scrollTop <= 0 && clientY > 0) {
						event.preventDefault();
					} else if (is_element_max_scrolled($el) && clientY < 0) {
						// Element is at the top of its scroll.
						event.preventDefault();
					}

					// Use a debounce function to reset the scroll position???
					// Reset the scroll to 1??? // $el.scrollTop = 1;
					// Reset the scroll to max-bottom - 1??? // $el.scrollTop = $el.scrollHeight - 1;
				}

				// AppCode:Scoped:Inner //

				// Enclose in a timeout to give the loader a chance to fade away.
				setTimeout(function() {
					// Embed the logo to the page if it exists.
					if (data.logo) {
						document.getElementById(
							"menu-dynamic-cont-logo"
						).innerHTML =
							data.logoHTML;
					}

					// Add the sidebar HTML.
					document.getElementById(
						"menu-dynamic-cont"
					).innerHTML = data.menu.join("");

					// Add the social links.
					if (data.socials) {
						document
							.getElementById("sidebar")
							.children[0].insertAdjacentHTML(
								"beforeend",
								data.socials
							);
					}

					// Animate the entire menu.
					document
						.getElementsByClassName("menu")[0]
						.classList.add("animate-fadein");

					// Parse the URL query parameters.
					var params = parameters();

					// Inject the file contents to the page. Provide the
					// inject function the page parameter or default to the
					// first file when the page parameter does not exist.
					inject(params.page ? params.page : data.first_file);
				}, 200);

				// EventListeners:Scoped:Inner //

				// When the URL changes (history) update the HTML content.
				window.addEventListener("popstate", function(event) {
					// Parse the URL query parameters.
					var params = parameters();

					// Inject the file contents to the page. Provide the
					// inject function the page parameter or default to the
					// first file when the page parameter does not exist.
					inject(params.page ? params.page : data.first_file);
				});

				// When the URL changes (history) update the HTML content.
				window.addEventListener(
					"resize",
					debounce(function(event) {
						// When the window is no longer in a mobile size
						// and the sidebar is showing, hide the sidebar and
						// reset the content + topbar.
						// [https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia]
						if (
							window.matchMedia("(min-width: 769px)").matches &&
							$overlay.style.display === "block"
						) {
							// Hide the sidebar.
							$sidebar.classList.remove("sidebar-show");
							$overlay.style.opacity = 0;

							// Slide the topbar + markdown contents to the right.
							$topbar.classList.remove("mobile-slide");
							$markdown.classList.remove("mobile-slide");

							setTimeout(function() {
								$overlay.style.display = "none";
							}, 150);
						}
					}),
					200
				);

				// Potential Android edge-effect when reaching the top or
				// bottom CSS.
				// height: 0px;width:${_width - 1}px;
				// background: rgba(0, 0, 0, 0.2);
				// top:${_top}px;left:${_left}px;
				// position: fixed;z-index:5;
				// border-radius: 0px 0px 250px 1200px/100px;
				// transition: height 0.2s ease-in-out;

				// [https://stackoverflow.com/a/30112044]
				// [https://stackoverflow.com/a/24915633]
				// Prevent all scrolling when scrolling on the soverlay.
				$overlay.addEventListener("wheel", function(e) {
					e.preventDefault();
				});

				// [https://stackoverflow.com/a/30112044]
				// When scrolling on the sidebar, keep all scrolling to the
				// sidebar itself. Do not allow any scrolling to pass the
				// sidebar. When the top and bottom are reached simply prevent
				// any browser default behavior to stop further scrolling.
				$sidebar.addEventListener("wheel", function(e) {
					if (e.deltaY < 0) {
						// Element is at the top of its scroll.
						if ($sidebar.scrollTop > 0 === false) {
							e.preventDefault();
						}
					} else {
						// Element is at the top of its scroll.
						if (
							!(
								$sidebar.scrollTop + $sidebar.clientHeight <
								$sidebar.scrollHeight
							)
						) {
							e.preventDefault();
						}
					}
				});

				// Listen to clicks.
				document.addEventListener("click", function(e) {
					// Get the target element.
					var $target = e.target;
					var filename;
					var classes = $target.classList;

					// Since using event delegation, check that the clicked
					// element is either the anchor element containing the
					// needed data-attribute or the anchor's parent li
					// element.

					// The clicked element is an li element since it has the
					// l-2 (level-2) class. Since this is the case get the
					// child element's (anchor element) data-attribute.
					if (classes.contains("l-2")) {
						// Get the data-attribute.
						filename = $target.children[0].getAttribute(
							"data-file"
						);

						// If this is the case then the anchor element itself was
						// clicked. Simply get the data-attribute.
					} else if ($target.parentNode.classList.contains("l-2")) {
						// Get the data-attribute.
						filename = $target.getAttribute("data-file");

						// Reset the target element.
						$target = $target.parentNode;
					} else if (classes.contains("link-doc")) {
						// Get the data-attribute.
						filename = $target.getAttribute("data-file");

						// Reset the target element.
						// $target = $target.parentNode;
						$target = document.querySelector(
							`a.link[data-file='${filename}']`
						).parentNode;
					} else if (
						classes.contains("link-heading") ||
						classes.contains("l-3")
					) {
						e.preventDefault();
						e.stopPropagation();

						if ($target.tagName !== "A") {
							// Get the anchor child element.
							$target = $target.children[0];
						}

						// Get the href.
						var href = $target.getAttribute("href");
						// Get the header.
						var $header = document.querySelector(
							`[href='${href}'][class='anchor']`
						).parentNode;

						// Remove the class before adding.
						$header.classList.remove("highlight");

						scroll(
							$delement,
							get_element_top_pos($header),
							SCROLL_TIME,
							function() {
								// Highlight the header.
								$header.classList.add("highlight");

								// Hide the mobile sidebar + overlay.
								if (
									getComputedStyle($overlay).display ===
									"block"
								) {
									// Hide the sidebar.
									$sidebar.classList.remove("sidebar-show");
									$overlay.style.opacity = 0;

									// Slide the topbar + markdown contents to the right.
									$topbar.classList.remove("mobile-slide");
									$markdown.classList.remove("mobile-slide");

									setTimeout(function() {
										$overlay.style.display = "none";
									}, 150);
								}
							}
						);

						// Don't store the same hash. Only store if the hash
						// is different than the current hash.
						if (location.hash !== href) {
							history.pushState({}, null, `${href}`);
						}

						return;
					} else if (classes.contains("btn-home")) {
						// Get the data-attribute.
						filename = data.first_file;

						// Reset the target element.
						$target = document.querySelector(
							`a.link[data-file='${filename}']`
						).parentNode;
					}

					// If filename variable is set then a menu item was
					// clicked. Therefore, insert the corresponding HTML into
					// the page.
					if (filename) {
						// Get the dir and file components from the file name.
						var parts = filename.split("/");
						var dir = parts[0];
						// Remove the dir from the parts.
						parts.shift();
						var file = parts.join("/");

						// Only store when the file name does not match the
						// current file name to prevent clogging the history.
						if (filename !== current_file) {
							history.pushState(
								{},
								null,
								`?page=${encodeURIComponent(`${dir}/${file}`)}`
							);
						}

						// Set the HTML.
						inject(filename, $target);

						// Scroll to the top of the page.
						scroll($delement, 0, SCROLL_TIME);

						e.preventDefault();
					}
				});

				// [http://patrickmuff.ch/blog/2014/10/01/how-we-fixed-the-webkit-overflow-scrolling-touch-bug-on-ios/]
				// [https://stackoverflow.com/a/33024813]
				// [https://stackoverflow.com/a/41601290]
				// [https://stackoverflow.com/a/41565471]
				if (touchsupport()) {
					document.addEventListener("touchstart", function(e) {
						// Get the target element.
						var $target = e.target;
						var classes = $target.classList;

						// The hamburger menu was clicked.
						if (classes.contains("mobile-menu-ham")) {
							// Show the sidebar.
							$sidebar.classList.add("sidebar-show");

							// Slide the topbar + markdown contents to the right.
							$topbar.classList.add("mobile-slide");
							$markdown.classList.add("mobile-slide");

							$overlay.style.display = "block";
							setTimeout(function() {
								$overlay.style.opacity = 1;
							}, 150);
						} else if (classes.contains("sidebar-overlay")) {
							// The sidebar overlay was clicked.

							// Hide the sidebar.
							$sidebar.classList.remove("sidebar-show");
							$target.style.opacity = 0;

							// Slide the topbar + markdown contents to the right.
							$topbar.classList.remove("mobile-slide");
							$markdown.classList.remove("mobile-slide");

							setTimeout(function() {
								$target.style.display = "none";
							}, 150);
						}

						// [https://stackoverflow.com/a/42288386]
						// [https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action]
						// [https://github.com/OwlCarousel2/OwlCarousel2/issues/1790]
						// [https://developers.google.com/web/updates/2017/01/scrolling-intervention]
						// e.preventDefault();
					});

					// Store the Y position on touch start.
					var _clientY = null;
					// The touchstart handler stores the Y position.
					var touchstart_handler = function(event) {
						if (event.targetTouches.length === 1) {
							// Detect single touch.
							_clientY = event.targetTouches[0].clientY;
						}
					};
					// The touchmove handler cancels the OS rubber band effect.
					var touchmove_handler = function(event) {
						if (event.targetTouches.length === 1) {
							// Get the correct element.
							var $el = $sidebar.contains(event.target)
								? $sidebar
								: $overlay;

							// Disable rubber banding.
							disable_rubber_band(event, $el, _clientY);
						}
					};

					// Touchstart/move event listeners.

					$sidebar.addEventListener(
						"touchstart",
						touchstart_handler,
						false
					);
					$sidebar.addEventListener(
						"touchmove",
						touchmove_handler,
						false
					);
					$overlay.addEventListener(
						"touchstart",
						touchstart_handler,
						false
					);
					$overlay.addEventListener(
						"touchmove",
						touchmove_handler,
						false
					);
				}
			})
			.catch(function(msg) {
				console.error(msg);
			});
	}
};
